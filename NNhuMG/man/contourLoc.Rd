% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/contourLoc.R
\name{contourLoc}
\alias{contourLoc}
\title{Contour-based Gating of Significant Subsets}
\usage{
contourLoc(data, fhat, offset = 0.1, n.levels = 50, alpha = 0.05,
  statsfun, peaks2merge = 4, minBins = 10,
  keep.level.by = c("max.bin.cor", "max.bin.num", "min.p.value"),
  plotit = TRUE)
}
\arguments{
\item{data}{frequency matrix used to test for group-level differences in \code{statsfun} with bins in columns and samples in rows}

\item{fhat}{object returned by \code{\link{kdeDiff}} or \code{\link[ks]{kde}}}

\item{offset}{value in [0, 1] specifying the probability for which regions are detected, i.e. the lowest magnitude 
at which contours are reported, Default: 0.1}

\item{n.levels}{number of levels at which contours are evaluated, Default: 50}

\item{alpha}{level of significance for testing group differences, Default: 0.05}

\item{statsfun}{a function that will take for each evaluated contour (aggre-) gated data and return a \emph{p}-value for 
group-level inference (see example for details). Currently implemented for binned data only.}

\item{peaks2merge}{number of peaks that a contour may contain. This allows to report larger contours at lower magnitude 
and is useful in the presence of spurious peaks, Default: 4}

\item{minBins}{minimum required number of observations that a contour must encompass to be reported, Default: 10}

\item{keep.level.by}{a character string of "max.bin.num", or "min.p.value", "max.bin.cor", indicating whether for each dens region
the largest contour (i.e. at lowest magnitude for which it belongs to the same peak(s)) will be reported, the contour with 
the most significant group-level statistic, or whether correlative structure of the data is taken into account, respectively. 
In the latter, an effective number of bins determines which contour with \emph{p}-value <= \code{alpha} to report.}

\item{plotit}{flag to plot detected contours, Default: TRUE}
}
\value{
A list object with following fields:
\describe{
  \item{\code{res}}{\describe{
                      \item{\code{peaks}}{list of peak indices for each contour}
                      \item{\code{p.value}}{list of p.values or NA for each contour}
                      \item{\code{boundary}}{list of x- and y-coordinates for each contour polyon}
                      \item{\code{bin.idx}}{list of indices of observations within each contour}
                      \item{\code{num.bins}}{list of observation numbers within each contour}
                      \item{\code{eff.bins}}{list of effective observation numbers within each contour}
                    }}
  \item{\code{update}}{indices of contours, corresponding to rows in \code{res}}
  \item{\code{fhat}}{input object returned by \code{\link{kdeDiff}} or \code{\link[ks]{kde}}}
  \item{\code{peaks}}{peak points matrix with coordinates and level in columns}
  \item{\code{levels}}{levels at which countours were evaluated}
  \item{\code{data}}{}
  \item{\code{minBins}}{}
  \item{\code{peaks2merge}}{}
  \item{\code{offset}}{}
  \item{\code{alpha}}{}
  \item{\code{statsfun}}{}
  \item{\code{keep.level.by}}{}
}
}
\description{
locates regions of density-'tagged' observations in two dimensions
}
\details{
The functionalities provided with \code{\link{contourLoc}} and accompanying functions (\code{\link{shrinkSpur}}, \code{\link{contourMerge}})
       integrate into a larger workflow and aim at facilitating exploration, interaction with, and interpretation of the cytometry data after statistical 
       testing in a 'high-resolution' setting. The input is expected to be an object returned by \code{\link{kdeDiff}}, where individual bin-coordinates
       (of a \code{\link[flowFP]{flowFPModel}} derived from a composite t-SNE map) as observations have been weighted by their \emph{p}-values prior   
       to kernel density estimation. The density estimate thus contains local information about the significance testing and this is exploited here to  
       locate regions encompassing significant bins. As such, \code{\link{contourLoc}} is \emph{per se} not designed for automated gating of the actual
       observations or events (although this works as well). This may more conveniently be achieved by \code{\link[flowStats]{curv2Filter}}. Note that 
       currently no print, show, or summary functions are implemented.
}
\examples{
\dontrun{

# mock 118 bin coordinates
set.seed(123)
x <- rbind(matrix(rnorm(100, sd = 0.3), ncol = 2,
                  dimnames=list(NULL, c("A", "B"))),
           matrix(rnorm(36, mean = 1, sd = 0.3), ncol = 2),
           matrix(rnorm(100, mean = -1, sd = 0.3), ncol = 2))
plot(x) # 3 subsets

# row indices of 2nd and 3rd subsets
sub2 <- 51:68
sub3 <- 69:118

# mock frequency data for 118 bins and 20 samples (10 each group)
b <- jitter(matrix(1, nrow=20, ncol=118))

# add frequency difference for 2nd subset
r1 <- matrix(rep(rnorm(10, 0.01, 0.005) , 18), ncol=18, byrow=TRUE)
b[1:10, sub2] <- b[1:10, sub2] + r1 # more in group 1
b[11:20, sub2] <- b[11:20, sub2] - r1

# add frequency difference within 3rd subset
r2 <- matrix(rep(rnorm(10, 0.01, 0.001) , 50), ncol=50, byrow=TRUE)
shift <-  (x[sub3, 2] / x[sub3, 1]) < 1 
b[1:10, sub3[shift]] <- b[1:10, sub3[shift]] - r2[, shift]
b[11:20, sub3[shift]] <- b[11:20, sub3[shift]] + r2[, shift]
b[1:10, sub3[!shift]] <- b[1:10, sub3[!shift]] + r2[, !shift]
b[11:20, sub3[!shift]] <- b[11:20, sub3[!shift]] - r2[, !shift]

# frequency mock ready
b <- sweep(b, 1, rowSums(b), '/')

# two one-sided tests to see direction of difference
pv1 <- apply(b, 2, function(x) wilcox.test(x[1:10], x[11:20], alternative="greater")$p.value)
pv2 <- apply(b, 2, function(x) wilcox.test(x[1:10], x[11:20], alternative="less")$p.value)

# scale p-values to weights
w1 <- threshold2one(-log2(p.adjust(pv1, "BH")), -log2(0.05))
w2 <- threshold2one(-log2(p.adjust(pv2, "BH")), -log2(0.05))

# get density estimate for bin coordinates
BW <- chooseBandWidth(x) 
f0 <- BW$fhats[[ BW$Hindex[1] ]]

# get density-difference with 'significance weights'
f1 <- kdeDiff(fhat=f0, w1=w1)
f2 <- kdeDiff(fhat=f0, w1=w2)

# statsfun for testing contour-gated data 
statsfun <- function(data) wilcox.test(data[1:10,], data[11:20,])$p.value	

# get subsets more abundant in group 1
gr <- contourLoc(data=b, fhat=f1, offset = 0.1, statsfun=statsfun, n.levels = 20, peaks2merge = 2, 
minBins = 4, keep.level.by = "min.p.value", plotit = FALSE)
plotContours(gr, fhat.levels=T, labels="peak.ids", xlim=c(-2, 2), ylim=c(-2, 2))

# get subsets more abundant in group 2
le <- contourLoc(data=b, fhat=f2, offset = 0.1, statsfun=statsfun, n.levels = 20, peaks2merge = 2, 
minBins = 4, keep.level.by = "min.p.value", plotit = FALSE)
plotContours(le, fhat.levels=T, labels="peak.ids", xlim=c(-2, 2), ylim=c(-2, 2))
}
}
\seealso{
\code{\link[grDevices]{contourLines}}
 \code{\link{shrinkSpur}}
 \code{\link{contourMerge}}
 \code{\link{plotContours}}
 \code{\link{plotPheno}}
 \code{\link{findCutoffs}}
 \code{\link{phenoReduce}}
}
